// Code generated by bpf2go; DO NOT EDIT.
//go:build mips || mips64 || ppc64 || s390x

package kernel

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"
	"structs"

	"github.com/cilium/ebpf"
)

type hardwarePerfStats struct {
	_               structs.HostLayout
	Cycles          uint64
	Instructions    uint64
	RefCycles       uint64
	CacheReferences uint64
	CacheMisses     uint64
	Branches        uint64
	BranchMisses    uint64
	L1dLoads        uint64
	L1dStores       uint64
	LlcLoads        uint64
	LlcLoadMisses   uint64
	LlcStores       uint64
	LlcStoreMisses  uint64
	DtlbLoads       uint64
	DtlbLoadMisses  uint64
	DtlbStores      uint64
	DtlbStoreMisses uint64
	BpuLoads        uint64
	BpuLoadMisses   uint64
}

// loadHardware returns the embedded CollectionSpec for hardware.
func loadHardware() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_HardwareBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load hardware: %w", err)
	}

	return spec, err
}

// loadHardwareObjects loads hardware and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*hardwareObjects
//	*hardwarePrograms
//	*hardwareMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadHardwareObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadHardware()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// hardwareSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type hardwareSpecs struct {
	hardwareProgramSpecs
	hardwareMapSpecs
	hardwareVariableSpecs
}

// hardwareProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type hardwareProgramSpecs struct {
	OnBpuLoadMisses   *ebpf.ProgramSpec `ebpf:"on_bpu_load_misses"`
	OnBpuLoads        *ebpf.ProgramSpec `ebpf:"on_bpu_loads"`
	OnBranchMisses    *ebpf.ProgramSpec `ebpf:"on_branch_misses"`
	OnBranches        *ebpf.ProgramSpec `ebpf:"on_branches"`
	OnCacheMisses     *ebpf.ProgramSpec `ebpf:"on_cache_misses"`
	OnCacheReferences *ebpf.ProgramSpec `ebpf:"on_cache_references"`
	OnCpuCycles       *ebpf.ProgramSpec `ebpf:"on_cpu_cycles"`
	OnDtlbLoadMisses  *ebpf.ProgramSpec `ebpf:"on_dtlb_load_misses"`
	OnDtlbLoads       *ebpf.ProgramSpec `ebpf:"on_dtlb_loads"`
	OnDtlbStoreMisses *ebpf.ProgramSpec `ebpf:"on_dtlb_store_misses"`
	OnDtlbStores      *ebpf.ProgramSpec `ebpf:"on_dtlb_stores"`
	OnInstructions    *ebpf.ProgramSpec `ebpf:"on_instructions"`
	OnL1dLoads        *ebpf.ProgramSpec `ebpf:"on_l1d_loads"`
	OnL1dStoreMisses  *ebpf.ProgramSpec `ebpf:"on_l1d_store_misses"`
	OnL1dStores       *ebpf.ProgramSpec `ebpf:"on_l1d_stores"`
	OnLlcLoadMisses   *ebpf.ProgramSpec `ebpf:"on_llc_load_misses"`
	OnLlcLoads        *ebpf.ProgramSpec `ebpf:"on_llc_loads"`
	OnLlcStoreMisses  *ebpf.ProgramSpec `ebpf:"on_llc_store_misses"`
	OnLlcStores       *ebpf.ProgramSpec `ebpf:"on_llc_stores"`
	OnRefCycles       *ebpf.ProgramSpec `ebpf:"on_ref_cycles"`
}

// hardwareMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type hardwareMapSpecs struct {
	ProcStatsMap *ebpf.MapSpec `ebpf:"proc_stats_map"`
}

// hardwareVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type hardwareVariableSpecs struct {
}

// hardwareObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadHardwareObjects or ebpf.CollectionSpec.LoadAndAssign.
type hardwareObjects struct {
	hardwarePrograms
	hardwareMaps
	hardwareVariables
}

func (o *hardwareObjects) Close() error {
	return _HardwareClose(
		&o.hardwarePrograms,
		&o.hardwareMaps,
	)
}

// hardwareMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadHardwareObjects or ebpf.CollectionSpec.LoadAndAssign.
type hardwareMaps struct {
	ProcStatsMap *ebpf.Map `ebpf:"proc_stats_map"`
}

func (m *hardwareMaps) Close() error {
	return _HardwareClose(
		m.ProcStatsMap,
	)
}

// hardwareVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to loadHardwareObjects or ebpf.CollectionSpec.LoadAndAssign.
type hardwareVariables struct {
}

// hardwarePrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadHardwareObjects or ebpf.CollectionSpec.LoadAndAssign.
type hardwarePrograms struct {
	OnBpuLoadMisses   *ebpf.Program `ebpf:"on_bpu_load_misses"`
	OnBpuLoads        *ebpf.Program `ebpf:"on_bpu_loads"`
	OnBranchMisses    *ebpf.Program `ebpf:"on_branch_misses"`
	OnBranches        *ebpf.Program `ebpf:"on_branches"`
	OnCacheMisses     *ebpf.Program `ebpf:"on_cache_misses"`
	OnCacheReferences *ebpf.Program `ebpf:"on_cache_references"`
	OnCpuCycles       *ebpf.Program `ebpf:"on_cpu_cycles"`
	OnDtlbLoadMisses  *ebpf.Program `ebpf:"on_dtlb_load_misses"`
	OnDtlbLoads       *ebpf.Program `ebpf:"on_dtlb_loads"`
	OnDtlbStoreMisses *ebpf.Program `ebpf:"on_dtlb_store_misses"`
	OnDtlbStores      *ebpf.Program `ebpf:"on_dtlb_stores"`
	OnInstructions    *ebpf.Program `ebpf:"on_instructions"`
	OnL1dLoads        *ebpf.Program `ebpf:"on_l1d_loads"`
	OnL1dStoreMisses  *ebpf.Program `ebpf:"on_l1d_store_misses"`
	OnL1dStores       *ebpf.Program `ebpf:"on_l1d_stores"`
	OnLlcLoadMisses   *ebpf.Program `ebpf:"on_llc_load_misses"`
	OnLlcLoads        *ebpf.Program `ebpf:"on_llc_loads"`
	OnLlcStoreMisses  *ebpf.Program `ebpf:"on_llc_store_misses"`
	OnLlcStores       *ebpf.Program `ebpf:"on_llc_stores"`
	OnRefCycles       *ebpf.Program `ebpf:"on_ref_cycles"`
}

func (p *hardwarePrograms) Close() error {
	return _HardwareClose(
		p.OnBpuLoadMisses,
		p.OnBpuLoads,
		p.OnBranchMisses,
		p.OnBranches,
		p.OnCacheMisses,
		p.OnCacheReferences,
		p.OnCpuCycles,
		p.OnDtlbLoadMisses,
		p.OnDtlbLoads,
		p.OnDtlbStoreMisses,
		p.OnDtlbStores,
		p.OnInstructions,
		p.OnL1dLoads,
		p.OnL1dStoreMisses,
		p.OnL1dStores,
		p.OnLlcLoadMisses,
		p.OnLlcLoads,
		p.OnLlcStoreMisses,
		p.OnLlcStores,
		p.OnRefCycles,
	)
}

func _HardwareClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed hardware_bpfeb.o
var _HardwareBytes []byte
